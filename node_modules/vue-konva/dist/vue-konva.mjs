import { defineComponent as P, getCurrentInstance as w, reactive as A, ref as h, onMounted as C, onUpdated as E, onBeforeUnmount as K, watch as N, h as T, onUnmounted as M, computed as R, toValue as _ } from "vue";
import g from "konva";
function p(a) {
  if (!g.autoDrawEnabled) {
    const o = a.getLayer() || a.getStage();
    o && o.batchDraw();
  }
}
const S = { key: !0, style: !0, elm: !0, isRootInsert: !0 }, y = ".vue-konva-event";
function L(a, o, i, e) {
  const n = a.__konvaNode, u = {};
  let r = !1;
  for (let t in i) {
    if (S.hasOwnProperty(t))
      continue;
    const s = t.slice(0, 2) === "on", d = i[t] !== o[t];
    if (s && d) {
      let l = t.slice(2).toLowerCase();
      l.slice(0, 7) === "content" && (l = "content" + l.slice(7, 1).toUpperCase() + l.slice(8)), n?.off(l + y, i[t]);
    }
    !o.hasOwnProperty(t) && n?.setAttr(t, void 0);
  }
  for (let t in o) {
    if (S.hasOwnProperty(t))
      continue;
    let s = t.slice(0, 2) === "on";
    const d = i[t] !== o[t];
    if (s && d) {
      let c = t.slice(2).toLowerCase();
      c.slice(0, 7) === "content" && (c = "content" + c.slice(7, 1).toUpperCase() + c.slice(8)), o[t] && (n?.off(c + y), n?.on(c + y, o[t]));
    }
    !s && (o[t] !== i[t] || e && o[t] !== n?.getAttr(t)) && (r = !0, u[t] = o[t]);
  }
  r && n && (n.setAttrs(u), p(n));
}
const I = "v";
function U(a) {
  function o(i) {
    return i?.__konvaNode ? i : i?.parent ? o(i.parent) : (console.error("vue-konva error: Can not find parent node"), null);
  }
  return o(a.parent);
}
function b(a) {
  return a.component ? a.component.__konvaNode || b(a.component.subTree) : null;
}
function j(a) {
  const { el: o, component: i } = a, e = b(a);
  if (o?.tagName && i && !e) {
    const n = o.tagName.toLowerCase();
    return console.error(
      `vue-konva error: You are trying to render "${n}" inside your component tree. Looks like it is not a Konva node. You can render only Konva components inside the Stage.`
    ), null;
  }
  return e;
}
function V(a) {
  const o = (n) => !!n && typeof n == "object" && "component" in n, i = (n) => Array.isArray(n), e = (n) => o(n) ? [n, ...e(n.children)] : i(n) ? n.flatMap(e) : [];
  return e(a.children);
}
function O(a, o) {
  const i = V(a), e = [];
  i.forEach((u) => {
    const r = j(u);
    r && e.push(r);
  });
  let n = !1;
  e.forEach((u, r) => {
    u.getZIndex() !== r && (u.setZIndex(r), n = !0);
  }), n && p(o);
}
const $ = g.default?.Stage || g.Stage, F = P({
  name: "Stage",
  props: {
    config: {
      type: Object,
      default: function() {
        return {};
      }
    },
    __useStrictMode: {
      type: Boolean
    }
  },
  inheritAttrs: !1,
  setup(a, { attrs: o, slots: i, expose: e }) {
    const n = w();
    if (!n) return;
    const u = A({}), r = h(null), t = new $({
      width: a.config.width,
      height: a.config.height,
      container: document.createElement("div")
      // Fake container. Will be replaced
    });
    n.__konvaNode = t, c();
    function s() {
      return n?.__konvaNode;
    }
    function d() {
      return n?.__konvaNode;
    }
    function c() {
      if (!n) return;
      const l = u || {}, v = {
        ...o,
        ...a.config
      };
      L(n, v, l, a.__useStrictMode), Object.assign(u, v);
    }
    return C(() => {
      r.value && (r.value.innerHTML = "", t.container(r.value)), c();
    }), E(() => {
      c(), O(n.subTree, t);
    }), K(() => {
      t.destroy();
    }), N(() => a.config, c, { deep: !0 }), e({
      getStage: d,
      getNode: s
    }), () => T("div", { ref: r, style: o?.style }, i.default?.());
  }
}), G = ".vue-konva-event", B = {
  Group: !0,
  Layer: !0,
  FastLayer: !0,
  Label: !0
};
function W(a, o) {
  return P({
    name: a,
    props: {
      config: {
        type: Object,
        default: function() {
          return {};
        }
      },
      __useStrictMode: {
        type: Boolean
      }
    },
    setup(i, { attrs: e, slots: n, expose: u }) {
      const r = w();
      if (!r) return;
      const t = A({}), s = new o();
      r.__konvaNode = s, r.vnode.__konvaNode = s, l();
      function d() {
        return r?.__konvaNode;
      }
      function c() {
        return r?.__konvaNode;
      }
      function l() {
        if (!r) return;
        const f = {};
        for (const m in r?.vnode.props)
          m.slice(0, 2) === "on" && (f[m] = r.vnode.props[m]);
        const x = t || {}, k = {
          ...e,
          ...i.config,
          ...f
        };
        L(r, k, x, i.__useStrictMode), Object.assign(t, k);
      }
      C(() => {
        const f = U(r)?.__konvaNode;
        f && "add" in f && f.add(s), p(s);
      }), M(() => {
        p(s), s.destroy(), s.off(G);
      }), E(() => {
        l(), O(r.subTree, s);
      }), N(() => i.config, l, { deep: !0 }), u({
        getStage: c,
        getNode: d
      });
      const v = B.hasOwnProperty(a);
      return () => v ? T("template", {}, n.default?.()) : null;
    }
  });
}
function Z(a, o, i) {
  const e = h(null), n = h("loading"), u = (t, s, d) => {
    n.value = "loading";
    const c = new Image();
    s && (c.crossOrigin = s), d && (c.referrerPolicy = d), c.onload = () => {
      e.value = c, n.value = "loaded";
    }, c.onerror = () => {
      e.value = null, n.value = "error";
    }, c.src = t;
  }, r = R(() => ({
    url: _(a),
    crossorigin: _(o),
    referrerPolicy: _(i)
  }));
  return N(
    r,
    ({ url: t, crossorigin: s, referrerPolicy: d }) => {
      t && u(t, s, d);
    },
    { immediate: !0 }
  ), [e, n];
}
const H = {
  install: (a, o) => {
    const i = o?.prefix || I, e = g.default || g, n = {
      Arc: e.Arc,
      Arrow: e.Arrow,
      Circle: e.Circle,
      Ellipse: e.Ellipse,
      FastLayer: e.FastLayer,
      Group: e.Group,
      Image: e.Image,
      Label: e.Label,
      Layer: e.Layer,
      Line: e.Line,
      Path: e.Path,
      Rect: e.Rect,
      RegularPolygon: e.RegularPolygon,
      Ring: e.Ring,
      Shape: e.Shape,
      Sprite: e.Sprite,
      Star: e.Star,
      Tag: e.Tag,
      Text: e.Text,
      TextPath: e.TextPath,
      Transformer: e.Transformer,
      Wedge: e.Wedge,
      ...o?.customNodes
    };
    [
      F,
      ...Object.entries(n).map(
        ([r, t]) => W(r, t)
      )
    ].forEach((r) => {
      a.component(`${i}${r.name}`, r);
    });
  }
};
export {
  H as default,
  Z as useImage
};
